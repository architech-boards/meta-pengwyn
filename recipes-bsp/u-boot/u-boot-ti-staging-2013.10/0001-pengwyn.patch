diff -Naur a/arch/arm/include/asm/arch-am33xx/ddr_defs.h b/arch/arm/include/asm/arch-am33xx/ddr_defs.h
--- a/arch/arm/include/asm/arch-am33xx/ddr_defs.h	2014-05-02 17:16:33.929309924 +0200
+++ b/arch/arm/include/asm/arch-am33xx/ddr_defs.h	2014-06-09 16:37:03.632133847 +0200
@@ -102,6 +102,22 @@
 #define MT41J512M8RH125_PHY_WR_DATA		0x74
 #define MT41J512M8RH125_IOCTRL_VALUE		0x18B
 
+/* Micron MT41K128M16JT-187E */
+#define MT41K128M16JT187E_EMIF_READ_LATENCY     0x100006
+#define MT41K128M16JT187E_EMIF_TIM1             0x0888A39B
+#define MT41K128M16JT187E_EMIF_TIM2             0x26337FDA
+#define MT41K128M16JT187E_EMIF_TIM3             0x501F830F
+#define MT41K128M16JT187E_EMIF_SDCFG            0x61C04AB2
+#define MT41K128M16JT187E_EMIF_SDREF            0x0000093B
+#define MT41K128M16JT187E_ZQ_CFG                0x50074BE4
+#define MT41K128M16JT187E_RATIO                 0x40
+#define MT41K128M16JT187E_INVERT_CLKOUT         0x01
+#define MT41K128M16JT187E_RD_DQS                0x3B
+#define MT41K128M16JT187E_WR_DQS                0x85
+#define MT41K128M16JT187E_PHY_WR_DATA           0xC1
+#define MT41K128M16JT187E_PHY_FIFO_WE           0x100
+#define MT41K128M16JT187E_IOCTRL_VALUE          0x18B
+
 /* Samsung K4B2G1646E-BIH9 */
 #define K4B2G1646EBIH9_EMIF_READ_LATENCY	0x100007
 #define K4B2G1646EBIH9_EMIF_TIM1		0x0AAAE51B
diff -Naur a/board/architech/pengwyn/board.c b/board/architech/pengwyn/board.c
--- a/board/architech/pengwyn/board.c	1970-01-01 01:00:00.000000000 +0100
+++ b/board/architech/pengwyn/board.c	2014-06-09 17:28:16.449503301 +0200
@@ -0,0 +1,222 @@
+/*
+ * board.c
+ *
+ * Board functions for ArchiTech Pengwyn board
+ *
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ *
+ * Copyright (C) 2014, Avnet Emg
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <spl.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/omap.h>
+#include <asm/arch/ddr_defs.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/mmc_host_def.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/mem.h>
+#include <asm/io.h>
+#include <asm/emif.h>
+#include <asm/gpio.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <cpsw.h>
+#include <power/tps65217.h>
+#include <power/tps65910.h>
+#include "board.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if defined(CONFIG_SPL_BUILD)
+
+/******************************************** SPL Board Init ********************************************/
+
+#ifdef CONFIG_SPL_OS_BOOT
+int spl_start_uboot(void)
+{
+    /* break into full u-boot on 'c' */
+    return (serial_tstc() && serial_getc() == 'c');
+}
+#endif /* CONFIG_SPL_OS_BOOT */
+
+void am33xx_spl_board_init(void)
+{
+    dpll_mpu_opp100.m = MPUPLL_M_720;
+    do_setup_dpll( &dpll_mpu_regs, &dpll_mpu_opp100 );
+}
+
+/******************************************** UART ********************************************/
+
+void set_uart_mux_conf(void)
+{
+    enable_uart0_pin_mux();
+}
+
+/******************************************** MUX ********************************************/
+
+void set_mux_conf_regs(void)
+{
+    enable_board_pin_mux();
+}
+
+/******************************************** RAM ********************************************/
+
+static struct emif_regs ddr3_emif_reg_data = {
+    .sdram_config           = MT41K128M16JT187E_EMIF_SDCFG,
+    .ref_ctrl               = MT41K128M16JT187E_EMIF_SDREF,
+    .sdram_tim1             = MT41K128M16JT187E_EMIF_TIM1,
+    .sdram_tim2             = MT41K128M16JT187E_EMIF_TIM2,
+    .sdram_tim3             = MT41K128M16JT187E_EMIF_TIM3,
+    .zq_config              = MT41K128M16JT187E_ZQ_CFG,
+    .emif_ddr_phy_ctlr_1    = MT41K128M16JT187E_EMIF_READ_LATENCY | PHY_EN_DYN_PWRDN,
+};
+
+static const struct cmd_control ddr3_cmd_ctrl_data = {
+    .cmd0csratio = MT41K128M16JT187E_RATIO,
+    .cmd0iclkout = MT41K128M16JT187E_INVERT_CLKOUT,
+
+    .cmd1csratio = MT41K128M16JT187E_RATIO,
+    .cmd1iclkout = MT41K128M16JT187E_INVERT_CLKOUT,
+
+    .cmd2csratio = MT41K128M16JT187E_RATIO,
+    .cmd2iclkout = MT41K128M16JT187E_INVERT_CLKOUT,
+};
+
+static const struct ddr_data ddr3_data = {
+    .datardsratio0 = MT41K128M16JT187E_RD_DQS,
+    .datawdsratio0 = MT41K128M16JT187E_WR_DQS,
+    .datafwsratio0 = MT41K128M16JT187E_PHY_FIFO_WE,
+    .datawrsratio0 = MT41K128M16JT187E_PHY_WR_DATA,
+};
+
+#define OSC (V_OSCK/1000000)
+
+const struct dpll_params dpll_ddr_pengwyn = {
+    303, OSC-1, 1, -1, -1, -1, -1
+};
+
+const struct dpll_params *get_dpll_ddr_params(void)
+{
+    return &dpll_ddr_pengwyn;
+}
+
+void sdram_init(void)
+{
+    config_ddr( 303, MT41K128M16JT187E_IOCTRL_VALUE, &ddr3_data, &ddr3_cmd_ctrl_data, &ddr3_emif_reg_data, 0 );
+}
+#endif /* defined(CONFIG_SPL_BUILD) */
+
+/******************************************** BOARD INIT ********************************************/
+
+/*
+ * Basic board specific setup.  Pinmux has been handled already.
+ */
+int board_init(void)
+{
+    gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+    gpmc_init();
+    return 0;
+}
+
+#ifdef CONFIG_BOARD_LATE_INIT
+int board_late_init(void)
+{
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+    setenv("board_name", "Pengwyn");
+    setenv("board_rev", "C");
+#endif /* CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG */
+    return 0;
+}
+#endif /* CONFIG_BOARD_LATE_INIT */
+
+/******************************************** NETWORK ********************************************/
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || (defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+static void cpsw_control(int enabled)
+{
+    /* VTP can be added here */
+    return;
+}
+
+static struct cpsw_slave_data cpsw_slaves[] = {
+    {
+        .slave_reg_ofs  = 0x208,
+        .sliver_reg_ofs = 0xd80,
+        .phy_addr       = 1,
+        .phy_if         = PHY_INTERFACE_MODE_MII,
+    },
+};
+
+static struct cpsw_platform_data cpsw_data = {
+    .mdio_base          = CPSW_MDIO_BASE,
+    .cpsw_base          = CPSW_BASE,
+    .mdio_div           = 0xff,
+    .channels           = 8,
+    .cpdma_reg_ofs      = 0x800,
+    .slaves             = 1,
+    .slave_data         = cpsw_slaves,
+    .ale_reg_ofs        = 0xd00,
+    .ale_entries        = 1024,
+    .host_port_reg_ofs  = 0x108,
+    .hw_stats_reg_ofs   = 0x900,
+    .bd_ram_ofs         = 0x2000,
+    .mac_control        = (1 << 5),
+    .control            = cpsw_control,
+    .host_port_num      = 0,
+    .version            = CPSW_CTRL_VERSION_2,
+};
+#endif /* (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || (defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD)) */
+
+#if defined(CONFIG_DRIVER_TI_CPSW) || (defined(CONFIG_USB_ETHER) && defined(CONFIG_MUSB_GADGET))
+
+static struct ctrl_dev *cdev = (struct ctrl_dev *)CTRL_DEVICE_BASE;
+
+int board_eth_init(bd_t *bis)
+{
+    int
+        rv,
+        n = 0;
+    uint8_t
+        mac_addr[6];
+    uint32_t
+        mac_hi,
+        mac_lo;
+
+    /* try reading mac address from efuse */
+    mac_lo = readl(&cdev->macid0l);
+    mac_hi = readl(&cdev->macid0h);
+    mac_addr[0] = mac_hi & 0xFF;
+    mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+    mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+    mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+    mac_addr[4] = mac_lo & 0xFF;
+    mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || (defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+    if (!getenv("ethaddr")) {
+        printf("<ethaddr> not set. Validating first E-fuse MAC\n");
+
+        if (is_valid_ether_addr(mac_addr))
+            eth_setenv_enetaddr("ethaddr", mac_addr);
+        else
+            puts( "No valid <ethaddr> found.\n" );
+    }
+
+    writel( MII_MODE_ENABLE, &cdev->miisel );
+
+    rv = cpsw_register(&cpsw_data);
+    if (rv < 0)
+        printf("Error %d registering CPSW switch\n", rv);
+    else
+        n += rv;
+#endif /* (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || (defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD)) */
+    return n;
+}
+#endif /* defined(CONFIG_DRIVER_TI_CPSW) || (defined(CONFIG_USB_ETHER) && defined(CONFIG_MUSB_GADGET)) */
diff -Naur a/board/architech/pengwyn/board.h b/board/architech/pengwyn/board.h
--- a/board/architech/pengwyn/board.h	1970-01-01 01:00:00.000000000 +0100
+++ b/board/architech/pengwyn/board.h	2014-06-09 16:40:28.529557938 +0200
@@ -0,0 +1,18 @@
+/*
+ *
+ * board.h
+ * 
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ * 
+ * Copyright (C) 2014, Avnet Emg
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _BOARD_H_
+#define _BOARD_H_
+
+void enable_uart0_pin_mux(void);
+void enable_board_pin_mux(void);
+
+#endif /* _BOARD_H_ */
diff -Naur a/board/architech/pengwyn/Makefile b/board/architech/pengwyn/Makefile
--- a/board/architech/pengwyn/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/board/architech/pengwyn/Makefile	2014-06-06 17:46:18.850529821 +0200
@@ -0,0 +1,38 @@
+#
+# Makefile
+#
+# Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+ifeq ($(CONFIG_SPL_BUILD)$(CONFIG_NOR_BOOT),y)
+COBJS	:= mux.o
+endif
+
+COBJS	+= board.o
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur a/board/architech/pengwyn/mux.c b/board/architech/pengwyn/mux.c
--- a/board/architech/pengwyn/mux.c	1970-01-01 01:00:00.000000000 +0100
+++ b/board/architech/pengwyn/mux.c	2014-06-09 17:32:40.750180592 +0200
@@ -0,0 +1,91 @@
+/*
+ * mux.c
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ * 
+ * Copyright (C) 2014 Avnet Emg
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/io.h>
+#include <i2c.h>
+#include "board.h"
+
+static struct module_pin_mux uart0_pin_mux[] = {
+    {OFFSET(uart0_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},          /* UART0_RXD */
+    {OFFSET(uart0_txd), (MODE(0) | PULLUDEN)},                      /* UART0_TXD */
+    {-1},
+};
+
+static struct module_pin_mux mii1_pin_mux[] = {
+    {OFFSET(mii1_rxerr), MODE(0) | RXACTIVE},                       /* MII1_RXERR */
+    {OFFSET(mii1_txen), MODE(0)},                                   /* MII1_TXEN  */
+    {OFFSET(mii1_rxdv), MODE(0) | RXACTIVE},                        /* MII1_RXDV  */
+    {OFFSET(mii1_txd3), MODE(0)},                                   /* MII1_TXD3  */
+    {OFFSET(mii1_txd2), MODE(0)},                                   /* MII1_TXD2  */
+    {OFFSET(mii1_txd1), MODE(0)},                                   /* MII1_TXD1  */
+    {OFFSET(mii1_txd0), MODE(0)},                                   /* MII1_TXD0  */
+    {OFFSET(mii1_txclk), MODE(0) | RXACTIVE},                       /* MII1_TXCLK */
+    {OFFSET(mii1_rxclk), MODE(0) | RXACTIVE},                       /* MII1_RXCLK */
+    {OFFSET(mii1_rxd3), MODE(0) | RXACTIVE},                        /* MII1_RXD3  */
+    {OFFSET(mii1_rxd2), MODE(0) | RXACTIVE},                        /* MII1_RXD2  */
+    {OFFSET(mii1_rxd1), MODE(0) | RXACTIVE},                        /* MII1_RXD1  */
+    {OFFSET(mii1_rxd0), MODE(0) | RXACTIVE},                        /* MII1_RXD0  */
+    {OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN},            /* MDIO_DATA  */
+    {OFFSET(mdio_clk), MODE(0) | PULLUP_EN},                        /* MDIO_CLK   */
+    {-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux[] = {
+    {OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},          /* MMC0_DAT3 */
+    {OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},          /* MMC0_DAT2 */
+    {OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},          /* MMC0_DAT1 */
+    {OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},          /* MMC0_DAT0 */
+    {OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},           /* MMC0_CLK  */
+    {OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},           /* MMC0_CMD  */
+    {OFFSET(mcasp0_aclkx),(MODE(4) | RXACTIVE | PULLUP_EN)},        /* MMC0_CD   */
+    {-1},
+};
+
+static struct module_pin_mux nand_pin_mux[] = {
+	{OFFSET(gpmc_ad0), (MODE(0) | PULLUP_EN | RXACTIVE)},	        /* NAND AD0     */
+	{OFFSET(gpmc_ad1), (MODE(0) | PULLUP_EN | RXACTIVE)},	        /* NAND AD1     */
+	{OFFSET(gpmc_ad2), (MODE(0) | PULLUP_EN | RXACTIVE)},	        /* NAND AD2     */
+	{OFFSET(gpmc_ad3), (MODE(0) | PULLUP_EN | RXACTIVE)},	        /* NAND AD3     */
+	{OFFSET(gpmc_ad4), (MODE(0) | PULLUP_EN | RXACTIVE)},	        /* NAND AD4     */
+	{OFFSET(gpmc_ad5), (MODE(0) | PULLUP_EN | RXACTIVE)},	        /* NAND AD5     */
+	{OFFSET(gpmc_ad6), (MODE(0) | PULLUP_EN | RXACTIVE)},	        /* NAND AD6     */
+	{OFFSET(gpmc_ad7), (MODE(0) | PULLUP_EN | RXACTIVE)},	        /* NAND AD7     */
+	{OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUP_EN)},         /* NAND WAIT    */
+	{OFFSET(gpmc_wpn), (MODE(7) | PULLUP_EN | RXACTIVE)},	        /* NAND_WPN     */
+	{OFFSET(gpmc_csn0), (MODE(0) | PULLUDEN)},	                    /* NAND_CS0     */
+	{OFFSET(gpmc_advn_ale), (MODE(0) | PULLUDEN)},                  /* NAND_ADV_ALE */
+	{OFFSET(gpmc_oen_ren), (MODE(0) | PULLUDEN)},	                /* NAND_OE      */
+	{OFFSET(gpmc_wen), (MODE(0) | PULLUDEN)},	                    /* NAND_WEN     */
+	{OFFSET(gpmc_be0n_cle), (MODE(0) | PULLUDEN)},	                /* NAND_BE_CLE  */
+	{-1},
+};
+
+void enable_uart0_pin_mux(void)
+{
+    configure_module_pin_mux( uart0_pin_mux );
+}
+
+void enable_board_pin_mux(void)
+{
+    configure_module_pin_mux( mii1_pin_mux );
+    configure_module_pin_mux( mmc0_pin_mux );
+    configure_module_pin_mux( nand_pin_mux );
+}
diff -Naur a/boards.cfg b/boards.cfg
--- a/boards.cfg	2014-05-02 17:16:34.185306706 +0200
+++ b/boards.cfg	2014-06-06 17:45:31.363126818 +0200
@@ -1210,3 +1210,4 @@
 Orphan  powerpc     mpc8xx         -           -               mbx8xx              MBX                                  -                                                                                                                                 -
 Orphan  powerpc     mpc8xx         -           -               mbx8xx              MBX860T                              -                                                                                                                                 -
 Orphan  powerpc     mpc8xx         -           -               nx823               NX823                                -                                                                                                                                 -
+Active  arm         armv7          am33xx      architech       pengwyn             pengwyn                              -                                                                                                                                 Alessandro Ratti <alessandro.ratti@silica.com>
diff -Naur a/drivers/mtd/nand/nand_ids.c b/drivers/mtd/nand/nand_ids.c
--- a/drivers/mtd/nand/nand_ids.c	2014-05-02 17:16:28.269381079 +0200
+++ b/drivers/mtd/nand/nand_ids.c	2014-06-09 18:17:10.156621608 +0200
@@ -110,6 +110,7 @@
 	{"NAND 1GiB 3,3V 8-bit",	0xD3, 0, 1024, 0, LP_OPTIONS},
 	{"NAND 1GiB 1,8V 16-bit",	0xB3, 0, 1024, 0, LP_OPTIONS16},
 	{"NAND 1GiB 3,3V 16-bit",	0xC3, 0, 1024, 0, LP_OPTIONS16},
+    {"NAND 1GiB 3,3V 8-bit",    0x38, 0, 1024, 0, LP_OPTIONS},
 
 	/* 16 Gigabit */
 	{"NAND 2GiB 1,8V 8-bit",	0xA5, 0, 2048, 0, LP_OPTIONS},
diff -Naur a/drivers/usb/musb-new/musb_uboot.c b/drivers/usb/musb-new/musb_uboot.c
--- a/drivers/usb/musb-new/musb_uboot.c	2014-05-02 17:16:34.373304343 +0200
+++ b/drivers/usb/musb-new/musb_uboot.c	2014-06-09 18:15:38.593772709 +0200
@@ -116,7 +116,7 @@
 {
 	u8 power;
 	void *mbase;
-	int timeout = MUSB_HOST_TIMEOUT;
+	int timeout = 0x003fffff;
 
 	if (!host) {
 		printf("MUSB host is not registered\n");
diff -Naur a/include/configs/pengwyn.h b/include/configs/pengwyn.h
--- a/include/configs/pengwyn.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/configs/pengwyn.h	2014-06-16 18:35:02.255987677 +0200
@@ -0,0 +1,283 @@
+/*
+ * pengwyn.h
+ *
+ * Copyright (C) 2014 Avnet Emg
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __PENGWYN_CONFIG_H
+#define __PENGWYN_CONFIG_H
+
+/*#define DEBUG*/
+
+#include <configs/ti_am335x_common.h>
+
+/* machine */
+#define MACH_TYPE_PENGWYN                           4928
+#define CONFIG_MACH_TYPE                            MACH_TYPE_PENGWYN
+
+/* clock */
+#define V_OSCK                                      24000000            /* clock output from T2 */
+#define V_SCLK                                      (V_OSCK)
+
+/* physical memory map */
+#define CONFIG_NR_DRAM_BANKS                        1                   /* 1 bank of DRAM */
+#define PHYS_DRAM_1                                 0x80000000          /* DRAM Bank #1 */
+#define CONFIG_MAX_RAM_BANK_SIZE                    (1024 << 20)        /* 1GB */
+#if defined(CONFIG_SYS_SDRAM_BASE)
+    #undef CONFIG_SYS_SDRAM_BASE
+#endif
+#define CONFIG_SYS_SDRAM_BASE                       PHYS_DRAM_1
+#define CONFIG_SYS_INIT_SP_ADDR                     (NON_SECURE_SRAM_END - GENERATED_GBL_DATA_SIZE)
+
+/* NS16550 */
+#define CONFIG_SYS_NS16550_COM1                     0x44e09000          /* Base EVM has UART0 */
+#define CONFIG_SYS_NS16550_COM2                     0x48022000          /* UART1 */
+#define CONFIG_SYS_NS16550_COM3                     0x48024000          /* UART2 */
+#define CONFIG_SYS_NS16550_COM4                     0x481a6000          /* UART3 */
+#define CONFIG_SYS_NS16550_COM5                     0x481a8000          /* UART4 */
+#define CONFIG_SYS_NS16550_COM6                     0x481aa000          /* UART5 */
+
+/* serial console */
+#define CONFIG_BAUDRATE                             115200
+#define CONFIG_SYS_BAUDRATE_TABLE                   { 110, 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 56000, 57600, 115200 }
+#define CONFIG_SERIAL1                              1
+#define CONFIG_CONS_INDEX                           1
+#define CONFIG_SYS_CONSOLE_INFO_QUIET
+
+/* shell */
+#undef  CONFIG_SYS_PROMPT
+#define CONFIG_SYS_PROMPT                           "Pengwyn U-Boot> "
+#undef  CONFIG_BOOTDELAY
+#define CONFIG_BOOTDELAY                            2
+
+/* environment */
+#define CONFIG_ENV_SIZE                             (512 << 10) /* 512 KB */
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+#ifndef CONFIG_SPL_BUILD
+
+    #undef  CONFIG_BOOTCOMMAND
+    #define CONFIG_BOOTCOMMAND \
+        "for target in ${boot_targets}; do " \
+            "echo Trying to boot from ${target}...; " \
+            "run args_${target}; " \
+            "run bootcmd_${target}; " \
+            "mw.b ${krnaddr} 0x00 0x00C00000; " \
+            "mw.b ${fdtaddr} 0x00 0x00080000; " \
+        "done; " \
+        "echo Impossible to get Linux running;"
+
+    #define CONFIG_EXTRA_ENV_SETTINGS \
+        "loaduenv=" \
+            "load ${boot_interface} ${boot_device}:${boot_partition} ${loadaddr} ${bootenv};\0" \
+        "importuenv=" \
+            "env import -t ${loadaddr} ${filesize};\0" \
+        "readuenv=" \
+            "if run loaduenv; then " \
+                "run importuenv; " \
+            "fi;\0" \
+        "args_net=" \
+            "setenv bootargs console=${console} ${optargs} root=/dev/nfs nfsroot=${serverip}:${rootpath}${nfsopts} rw ip=${ipaddr}:${serverip}:${gw_ip}:${netmask}:${hostname}::off;\0" \
+        "bootcmd_net=" \
+            "if ping ${serverip}; then " \
+                "if tftpboot ${loadaddr} ${tftppath}/${bootenv}; then " \
+                    "run importuenv; " \
+                "fi; " \
+                "tftpboot ${krnaddr} ${tftppath}/${krnfile}; " \
+                "tftpboot ${fdtaddr} ${tftppath}/${fdtfile}; " \
+                "${boot_command} ${krnaddr} - ${fdtaddr}; " \
+            "fi;\0" \
+        "args_nand=" \
+            "setenv boot_device; " \
+            "setenv boot_partition; " \
+            "setenv boot_interface; " \
+            "setenv bootargs console=${console} ${optargs} ubi.mtd=9 root=ubi0:rootfs rootfstype=ubifs rw,rootwait;\0" \
+        "bootcmd_nand=" \
+            "nand read ${krnaddr} NAND.kernel; " \
+            "nand read ${fdtaddr} NAND.u-boot-spl-os; " \
+            "${boot_command} ${krnaddr} - ${fdtaddr};\0" \
+        "args_usb=" \
+            "setenv boot_interface usb; " \
+            "setenv boot_device 0; " \
+            "setenv boot_partition 1; " \
+            "setenv bootargs console=${console} ${optarg} root=/dev/sda1 rw,rootwait;\0" \
+        "bootcmd_usb=" \
+            "usb start 0; " \
+            "if usb dev 0; then " \
+                "run readuenv; " \
+                "load usb ${boot_device}:${boot_partition} ${krnaddr} ${krnfile}; " \
+                "load usb ${boot_device}:${boot_partition} ${fdtaddr} ${fdtfile}; " \
+                "${boot_command} ${krnaddr} - ${fdtaddr}; " \
+            "fi;\0" \
+        "args_mmc=" \
+            "setenv boot_interface mmc; " \
+            "setenv boot_device 0; " \
+            "setenv boot_partition 1; " \
+            "setenv bootargs console=${console} ${optargs} root=/dev/mmcblk0p2 rw,rootwait;\0" \
+        "bootcmd_mmc=" \
+            "if mmc rescan; then " \
+                "mmc dev ${boot_device}; " \
+                "run readuenv; " \
+                "load mmc ${boot_device}:${boot_partition} ${krnaddr} ${krnfile}; " \
+                "load mmc ${boot_device}:${boot_partition} ${fdtaddr} ${fdtfile}; " \
+                "${boot_command} ${krnaddr} - ${fdtaddr}; " \
+            "fi;\0" \
+        "boot_targets=mmc nand\0" \
+        "mtdids=" MTDIDS_DEFAULT "\0" \
+        "mtdparts=" MTDPARTS_DEFAULT "\0" \
+        "ipaddr=192.168.0.10\0" \
+        "serverip=192.168.0.100\0" \
+        "netmask=255.255.255.0\0" \
+        "bootenv=uEnv.txt\0" \
+        "krnfile=zImage\0" \
+        "fdtfile=pengwyn.dtb\0" \
+        "krnaddr=0x80200000\0" \
+        "fdtaddr=0x80F80000\0" \
+        "loadaddr=0x80200000\0" \
+        "console=ttyO0,115200n8\0" \
+        "optargs=consoleblank=0 earlyprintk\0" \
+        "boot_command=bootz\0" \
+        "rootpath=/mnt/architech/pengwyn\0" \
+        "tftppath=architech/pengwyn\0" \
+        "nfsopts=\0" \
+        "gw_ip=\0" \
+        "hostname=\0"
+
+#endif
+
+/* SPL */
+#undef  CONFIG_SPL_OS_BOOT
+#define CONFIG_SPL_POWER_SUPPORT
+#define CONFIG_SPL_YMODEM_SUPPORT
+#define CONFIG_SPL_ETH_SUPPORT
+#define CONFIG_SPL_MUSB_NEW_SUPPORT
+#define CONFIG_SPL_NET_SUPPORT
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_NET_VCI_STRING                       "Pengwyn U-Boot SPL"
+#define CONFIG_SPL_LDSCRIPT                             "$(CPUDIR)/am33xx/u-boot-spl.lds"
+
+/* enhance (e)MMC support / experience */
+#define CONFIG_CMD_GPT
+#define CONFIG_EFI_PARTITION
+#define CONFIG_PARTITION_UUIDS
+#define CONFIG_CMD_PART
+
+/* NAND support */
+#define CONFIG_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_SAVEENV
+#define CONFIG_SYS_NAND_PAGE_SIZE                       4096
+#define CONFIG_SYS_NAND_OOBSIZE                         224
+#define CONFIG_SYS_NAND_BLOCK_SIZE                      (128*4096)
+#define CONFIG_SPL_NAND_DEVICE_WIDTH                    8
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_PAGE_COUNT                      (CONFIG_SYS_NAND_BLOCK_SIZE / CONFIG_SYS_NAND_PAGE_SIZE)
+#define CONFIG_NAND_OMAP_GPMC
+#define CONFIG_NAND_OMAP_ELM
+#define CONFIG_SYS_NAND_BASE                            (0x08000000)
+#define CONFIG_SYS_MAX_NAND_DEVICE                      1
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+#define CONFIG_SYS_NAND_BAD_BLOCK_POS                   NAND_LARGE_BADBLOCK_POS
+#define CONFIG_SYS_NAND_ECCPOS                          {  2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,\
+                                                          18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,\
+                                                          34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,\
+                                                          50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,\
+                                                          66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,\
+                                                          82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,\
+                                                          98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113,\
+                                                         114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129,\
+                                                         130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145,\
+                                                         146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161,\
+                                                         162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,\
+                                                         178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193,\
+                                                         194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209} 
+#define CONFIG_SYS_NAND_ECCSIZE                         512
+#define CONFIG_SYS_NAND_ECCBYTES                        26
+#define CONFIG_NAND_OMAP_ECCSCHEME                      OMAP_ECC_BCH16_CODE_HW
+#define CONFIG_MTD_DEVICE
+#define CONFIG_CMD_MTDPARTS
+#if defined(MTDIDS_DEFAULT)
+    #undef MTDIDS_DEFAULT
+#endif
+#define MTDIDS_DEFAULT                                  "nand0=nand.0"
+#if defined(MTDPARTS_DEFAULT)
+    #undef MTDPARTS_DEFAULT
+#endif
+#define MTDPARTS_DEFAULT                                "mtdparts=nand.0:" \
+                                                        "512k(NAND.SPL)," \
+                                                        "512k(NAND.SPL.backup1)," \
+                                                        "512k(NAND.SPL.backup2)," \
+                                                        "512k(NAND.SPL.backup3)," \
+                                                        "512k(NAND.u-boot-spl-os)," \
+                                                        "1536k(NAND.u-boot)," \
+                                                        "512k(NAND.u-boot-env)," \
+                                                        "512k(NAND.u-boot-env.backup1)," \
+                                                        "12288K(NAND.kernel)," \
+                                                        "-(NAND.rootfs)"
+#undef  CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_OFFSET                               0x00400000
+#define CONFIG_ENV_OFFSET_REDUND                        0x00480000
+#define CONFIG_SYS_ENV_SECT_SIZE                        CONFIG_SYS_NAND_BLOCK_SIZE
+/* NAND: SPL related configs */
+#define CONFIG_SPL_NAND_AM33XX_BCH
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_NAND_BASE
+#define CONFIG_SPL_NAND_DRIVERS
+#define CONFIG_SPL_NAND_ECC
+#define CONFIG_SYS_NAND_U_BOOT_START                    CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_NAND_U_BOOT_OFFS                     0x00280000
+/* NAND: SPL falcon mode related configs */
+#ifdef CONFIG_SPL_OS_BOOT
+    #define CONFIG_CMD_SPL_NAND_OFS                     0x00200000 /* os parameters */
+    #define CONFIG_SYS_NAND_SPL_KERNEL_OFFS             0x00500000 /* kernel offset */
+    #define CONFIG_CMD_SPL_WRITE_SIZE                   0x2000
+#endif
+
+/*
+ * USB configuration.  We enable MUSB support, both for host and for
+ * gadget.  We set USB0 as peripheral and USB1 as host, based on the
+ * board schematic and physical port wired to each.  Then for host we
+ * add mass storage support and for gadget we add both RNDIS ethernet
+ * and DFU.
+ */
+#define CONFIG_USB_MUSB_DSPS
+#define CONFIG_ARCH_MISC_INIT
+#define CONFIG_MUSB_GADGET
+#define CONFIG_MUSB_PIO_ONLY
+#define CONFIG_MUSB_DISABLE_BULK_COMBINE_SPLIT
+#define CONFIG_USB_GADGET
+#define CONFIG_USB_GADGET_DUALSPEED
+#define CONFIG_USB_GADGET_VBUS_DRAW                     2
+#define CONFIG_MUSB_HOST
+#define CONFIG_AM335X_USB0
+#define CONFIG_AM335X_USB0_MODE                         MUSB_PERIPHERAL
+#define CONFIG_AM335X_USB1
+#define CONFIG_AM335X_USB1_MODE                         MUSB_HOST
+
+#ifdef CONFIG_MUSB_HOST
+    #define CONFIG_CMD_USB
+    #define CONFIG_USB_STORAGE
+#endif
+
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_USBETH_SUPPORT)
+    /* disable host part of MUSB in SPL */
+    #undef CONFIG_MUSB_HOST
+    /*
+     * Disable CPSW SPL support so we fit within the 101KiB limit.
+     */
+    #undef CONFIG_SPL_ETH_SUPPORT
+#endif
+
+/* Network. */
+#define CONFIG_PHYLIB
+
+#endif  /* ! __PENGWYN_CONFIG_H */
